---
title: "Analysis of Qualifying for the 2021 Formula One Season, Part 1: Data Preparation"
output: html_document
editor_options: 
  chunk_output_type: console
---


# Analysis Focus

<br/>

This analysis is intended to be an introduction to Formula One qualifying data and a demonstration on how to prepare and clean data for a descriptive analysis on Track Evolution using machine learning and statistical modeling.

<br/>

# Introduction to Formula One

</br>

Formula One is a complicated sport. One way it captivates in its uniqueness from other motor sports in that the definition of "success" isn't simply about one driver, but massive teams of engineers building the best car possible over the course of a season. For the ten teams currently racing in Formula One there are a variety of ways to achieve success over the course of the season, but the first priority is to win the World Constructors Championship. This is done by each of a team's respective two drivers [combining for the most points](https://inews.co.uk/sport/formula-one/f1-points-2021-scoring-system-how-many-win-places-407130) compared to any other teams' two drivers on the grid through the course of the season. 

<br/>

Following the desire of wanting to know exactly to judge what contributes to a (Formula One) team's success can lead fans to a continuous and contentious cycle of questions. For example, these questions may be:

  - Was one of a team's drivers faster than the other?
  - Are individual teams generally faster than others?
  - What contributes to a team being fast?

<br/>

The problem to directly answering a lot of questions about driver skill or pace is that there are a lot of influences on driver performance that are not, well, a driver's performance. While F1 features some of the best racing drivers in the world, you don't need to be an expert of the sport to realize that the car a team builds for the driver will generally be the biggest gainer in lap time for the average driver. For starters, you can put the best drivers in the sport today - Lewis Hamilton or Max Verstappen - in the 2021 Haas and they are likely not scoring a point in the season, let alone battling for the World Drivers Championship during the last race of the season in Abu Dhabi.

<br/>

So we know that drivers across different teams cannot be compared on a level playing field, due to car speed and different strengths and weaknesses of each team's car that individual drivers must adapt to, but there are also other factors to consider. I would like to think we could use race results to compare drivers within teams, but even then there are many factors at play during the race. For instance, F1 cars have many different engine modes and energy mappings (known as [KERS: Kinetic Energy Recovery System](https://www.racecar-engineering.com/articles/the-basics-of-f1-kers/)), or more-simply put: ways to pick-and-choose *when and where* to maximize speed of the car throughout a lap around a track. 

<br/>

So now that we can generally rule out the race as a level-playing field for analysis, we can turn our attention to qualifying. Qualifying is perhaps the only session in a Grand Prix weekend in which drivers within teams can be judged on a level playing field. The goal for qualifying is simple: go as fast as possible over one lap. While it is very possible for some drivers to be faster over one lap and there may be some general set up differences (faster through corners at a cost of straight-line speed or vice-versa), rather than in race conditions, this is the only time for a team's drivers to be on equal engine modes and fuel levels. So with that, we know that there is one additional variable that plays into *all* cars' performance throughout a session, which is a term known as **track evolution**. 

<br/>

Track evolution is what we'll primarily be interested in exploring for this analysis, and is the result of track conditions improving as more laps are run throughout a session under dry conditions. As F1 cars race around a track, their tires shed large amounts of rubber as they wear which gets ingrained into the fibers, cracks, and crevices of a track's surface. As this happens, cars have more-and-more grip as the rubber from tires meets the progressively-grippier and rubber-filled track surface. This phenomenon is a big reason why lap times typically improve, for all teams, as a session progresses. So how can we analyze this? 


<br/>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# load packages
if (!require(tidyverse)) {
  install.packages("tidyverse")
}
if (!require(scales)) {
  install.packages("scales")
}
if (!require(patchwork)) {
  install.packages("patchwork")
}
if (!require(jcolors)) {
  install.packages("jcolors")
}
if (!require(knitr)) {
  install.packages("knitr")
}
if (!require(lubridate)) {
  install.packages("lubridate")
}
if (!require(tidymodels)) {
  install.packages("tidymodels")
}
if (!require(janitor)) {
  install.packages("janitor")
}
if (!require(kableExtra)) {
  install.packages("kableExtra")
}
if (!require(reticulate)) {
  install.packages("reticulate")
}
if (!require(fuzzyjoin)) {
  install.packages("fuzzyjoin")
}
if (!require(mgcv)) {
  install.packages("mgcv")
}
if (!require(zoo)) {
  install.packages("zoo")
}
if (!require(ggrepel)) {
  install.packages("ggrepel")
}

# this loads custom plot theme from saved location

source('~/Documents/Projects/tools/theme_main.R')

# loading in helper functions

source('~/Documents/Projects/ExploreF1/helper_functions_track_evo.R')

```


  
```{r, message=FALSE, warning=FALSE, echo=FALSE, eval=FALSE}

theme_main_add <- function() {
  
    theme(plot.title = element_text(hjust = 0),
        plot.subtitle = element_text(face = "italic",
                                     hjust = 0),
        plot.background = element_rect(fill = NA,
                                       color = "black",
                                       size = 2)
        )
  
}

```


## Data Acquisition

Fortunately, there are now ways for the general public to capture F1 data, and thanks to the [FastF1 API](https://theoehrly.github.io/Fast-F1/), it is possible for me to get my hands on and analyze. The one caveat to this API is that it utilizes Python, while I am more adept with a statistical programming language known as R. Because of this, I had create the functions to extract the data in Python and transfer that data to R in order for me to be more-comfortable in data preparation and analysis. 


```{r}

Sys.setenv(RETICULATE_PYTHON = "/Users/colinrenville/.pyenv/versions/3.9.9/bin/python3.9")


```

[With this code](https://github.com/renville-colin/f1_track_evo/blob/main/ExploreF1_data_pull.py), the functions created in Python and the *source_python* function allows us to use these in the R environment.

```{r}

reticulate::source_python("ExploreF1_data_pull.py")

```

```{python, eval=FALSE, echo=FALSE}

import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import fastf1 as ff1
from fastf1 import plotting
from time import sleep

# set cache directory

ff1.Cache.enable_cache('/Users/colinrenville/Documents/Projects/ExploreF1/cache')

# function that loads driver lookup
# this will be needed for telemetry data

def get_driver_lookup(season, circuit, session):
  """
  
  """

  session_data = ff1.get_session(season, circuit, session)
  session_laps_data = session_data.load_laps(with_telemetry=True)
  
  session_laps_car_data = session_laps_data
  
  # cant figure out any other way to remedy slice warning
  session_laps_car_data_copy = session_laps_car_data.copy()
  col_delta_time = list(session_laps_car_data_copy.loc[:,session_laps_car_data_copy.dtypes == 'timedelta64[ns]'])  
    
  # clean this up
    
  for col in col_delta_time:
    
    session_laps_car_data_copy.loc[:,col] = session_laps_car_data_copy.loc[:,col].dt.total_seconds()
    
  session_laps_driver_list = pd.unique(session_laps_car_data_copy['Driver'])
  
  return session_laps_driver_list
  

# parameterized function to return telemetry data
# car_data() and pos_data() are the truth, telemetry is imputed
## start with telemetry then correct where needed

def get_driver_data(season, circuit, session, driver, data_type, cached_flag='False'):
  """
  
  """

  season = int(season)
  
  session_data = ff1.get_session(season, circuit, session)
  session_laps_data = session_data.load_laps(with_telemetry=True)
  
  if data_type.lower() == 'telemetry':
    
    session_laps_car_data = session_laps_data.pick_driver(driver).get_telemetry()
    
  elif data_type.lower() == 'laps':
    
    if driver.upper() != 'ALL':
    
      session_laps_car_data = session_laps_data.pick_driver(driver)
      
    else:
      
      session_laps_car_data = session_laps_data
    
  # cant figure out any other way to remedy slice warning
  session_laps_car_data_copy = session_laps_car_data.copy()
  col_delta_time = list(session_laps_car_data_copy.loc[:,session_laps_car_data_copy.dtypes == 'timedelta64[ns]'])
  
  # clean this up / consolidate code from other functions
    
  for col in col_delta_time:
    
    session_laps_car_data_copy.loc[:,col] = session_laps_car_data_copy.loc[:,col].dt.total_seconds()
    
  # source this script then test this line
  
  # session_laps_car_data_copy = session_laps_car_data_copy.reset_index()
  
  session_laps_car_data_copy['season'] = season
  session_laps_car_data_copy['raceName'] = circuit
  session_laps_car_data_copy['session'] = session
  
  # pause the function after each scrape to not spam
  
  if cached_flag == 'False' :
    
    sleep(7)
    
  return session_laps_car_data_copy


def get_weekend_gp(season='2021') :
  """
  
  """
  
  list_sessions = []
  
  # defaulting as this for now.. can improve if needed
  
  for i in range(1,23,1):
  
    list_sessions.append(ff1.core.ergast.fetch_weekend(season, i))
    
  circuit_df = pd.DataFrame(list_sessions)
  
  # unlist circuit_df:Circuit and Circuit:Location columns
  
  circuits = pd.DataFrame(circuit_df['Circuit'].tolist())
  locations = pd.DataFrame(circuits['Location'].tolist())
  
  circuit_df = pd.concat([circuit_df, circuits, locations], axis = 1)
  circuit_df = circuit_df.drop(['Circuit', 'Location', 'url'], axis = 1)
  
  return circuit_df


```


# Analyzing one race weekend: Abu Dhabi 

Now we can call the function: **get_driver_data**, and load data for the Abu Dhabi's 2021 qualifying session. 

```{r}

ad_quali_2021_l <- get_driver_data(season = '2021',
                                   circuit = 'Abu Dhabi',
                                   session = 'Q',
                                   driver = 'ALL',
                                   data_type = 'laps')

```

</br>

So let's take a look at 5 rows the data we just loaded in to get a sense of what we're working with..


```{r}

ad_quali_2021_l %>%
  head() %>%
  kbl()

```

<br/>

Ouuuch. Even for this small sample of laps for Lewis Hamilton, already, I will list out some issues that I see:

1. There are particular values labeled "NaN". These are values that are missing entirely.
2. The LapTime column has values that vary heavily.


## Data cleaning and preparation

Digging into the LapTime column, and relating it to what's happening in a qualifying session for a driver, we can theorize why there might be no lap time for a driver, or why there would be a high or low value for a lap time when it does exist. The answer is simple as this dataset gives us a row for every single time a driver passes the start/finish line. This forces us to think about what we truly want out of this analysis. For instance, drivers will almost always exit the pit lane and coast around the track prior to their fast lap to avoid tire wear, and then once again coast around to the pits following their run. We do not want these laps included in our analysis of track evolution, and creating our first plot below of all lap times we can see why this is problematic. 


```{r, warning=FALSE, message=FALSE, fig.align='center'}

ad_quali_2021_l %>%
  ggplot(aes(x = LapStartTime, y = LapTime)) +
  geom_point(color = "#5a0d9e",
             alpha = 0.6) +
  labs(title = "Abu Dhabi 2021 Qualifying, all laps from raw data",
       subtitle = expression(paste("Plotting the entire dataset shows we have fast laps and slow laps, we are also missing Lap Times for ", bold("106 of 328 laps"))),
       x = "Lap Start Time",
       y = "Lap Time") +
  scale_x_continuous() +
  sec_lab_convert(axis = "y",
                  int_sec = 10) +
  theme_main() +
  theme_main_add() 

```

Now that's a mess! But, it's an informative mess. We can see genuine separation for Lap Times between what we can assume to be fast laps (huddled around the 1M 25S mark of the y axis) and slow laps that seemingly have more variance in comparison.

This is where the data cleaning really begins. And instead of just posting a blob of code, I aim to show specific cases of incorrect data and what I am doing to treat these cases. 

Below will be data cleaning for the following cases:

  1. Missing sector times
  2. Missing LapTime
  3. No session number data


```{r}

ad_quali_2021_l <- ad_quali_2021_l %>%
  # prune out what isnt being used below
  # arrange(LapStartTime) %>%
  group_by(Driver) %>%
  mutate(Compound = factor(Compound, levels = c("SOFT", "MEDIUM", "HARD")),
         LapTime_per = seconds_to_period(LapTime),
         next_lap_StartTime = lead(LapStartTime),
         Sector1SessionTime2 = (next_lap_StartTime - (Sector2Time + Sector3Time)),
         Sector1Time3 = (next_lap_StartTime - PitOutTime - Sector2Time - Sector3Time),
         Sector3Time2 = (PitInTime - Sector2SessionTime),
         LapTime4 = coalesce(LapTime,
                             (Sector1Time + Sector2Time + Sector3Time),
                             (Sector1Time3 + Sector2Time + Sector3Time)),
         Sector1Time_outlap = ifelse(!is.na(PitOutTime), (Sector2SessionTime-PitOutTime-Sector2Time), NA),
         # LapStartTime alone should not be used for this logic
         # use PitOutTime as LapStartTime for outlaps, LapStartTime for non-outlaps
         coal_LapStartTime = coalesce(PitOutTime, LapStartTime),
         LapTime5 = coalesce(LapTime4,
                            (PitInTime - LapStartTime) # for laps occuring during a red flag
                            ),
         InLap_flag = if_else(!is.na(PitInTime), 1, 0),
         OutLap_flag = if_else(!is.na(PitOutTime), 1, 0),
         coal_Sector1Time = coalesce(Sector1Time, Sector1Time3),
         coal_Sector3Time = coalesce(Sector3Time, Sector3Time2)) %>%
  ungroup() %>%
  group_by(season, raceName) %>%
  mutate(lap_start_rownum = (dplyr::row_number(coal_LapStartTime) - 1),
         scale_LapTime5 = scale(LapTime5)) %>%
  ungroup()

# editing below... 

ad_quali_2021_l_scaled <- ad_quali_2021_l %>%
  # any filtering that gets added to hclust_exlude() needs to be replciated here
  filter(InLap_flag == 0 & OutLap_flag == 0) %>%
  select(raceName, season, Driver, DriverNumber, LapNumber, InLap_flag,
         OutLap_flag, coal_Sector1Time, Sector2Time, coal_Sector3Time,
         LapTime5, scale_LapTime5) %>%
  mutate(scale_Sector1Time = scale(coal_Sector1Time),
         scale_Sector2Time = scale(Sector2Time),
         scale_Sector3Time = scale(coal_Sector3Time),
         scale_LapTime5_filtered = scale(LapTime5)) %>%
  select(-c(Driver, LapTime5, InLap_flag, OutLap_flag, coal_Sector1Time, Sector2Time,
            coal_Sector3Time, scale_LapTime5))

# rejoin scaled, filtered data onto primary df

ad_quali_2021_l <- ad_quali_2021_l %>%
  left_join(ad_quali_2021_l_scaled, by = c("season" = "season",
                                     "raceName" = "raceName",
                                     "DriverNumber" = "DriverNumber",
                                     "LapNumber" = "LapNumber"))

```

#### 0. Here is what a clean row of data should look like (fast lap)

This lap below by Lewis Hamilton, is a lap we know to be his last fast lap attempt of Q3 from film. Further, this was his fastest lap of the session. Using this info we can see in his data below that there are correctly no values for PitInTime or PitOutTime, in addition to accurate values for all sector time fields and a matching value for the columns **LapTime** and my created column: **LapTime5**.


```{r}

ad_quali_2021_l %>%
  select(Driver, DriverNumber, LapNumber, PitInTime, PitOutTime,
           Sector1SessionTime, Sector2SessionTime, Sector3SessionTime,
           Sector1Time, Sector2Time, Sector3Time, LapTime,
           LapTime5) %>%
  filter(Driver == "HAM" & LapNumber == 17) %>%
  kbl() %>%
  kable_styling(position = "center")
  

```

What is LapTime5? This is a calculated column by me to use in cases where there is no value for LapTime, but we can calculate what a driver's lap time is by using other fields that *are* filled. 

**For example...**

<br/>

#### 1. Laps with missing sector times


```{r, echo=FALSE, eval=FALSE}

selected_lap_vars <- c("Sector1Time", "Sector2Time")

ad_quali_2021_l %>%
  select(Driver, DriverNumber, LapNumber, PitInTime, PitOutTime,
         Sector1SessionTime, Sector2SessionTime, Sector3SessionTime,
         Sector1Time, Sector2Time, Sector3Time, LapTime,
         LapTime5) %>%
    filter(if_any(selected_lap_vars, is.na)) %>% View() 


```

For our first problematic lap example below, it is one of the more common cases in which a driver enters or exits the pit lane during the lap. By F1 standards, this makes sense as to why there isn't an official lap time as the entrance of pit lane is prior to the start/finish line and the exit of pit lane is after the start/finish line. So this leads to a bit of a gap in the data for these "In Laps" and "Out Laps".

<br/>

Below is an "In Lap" from Lando Norris. He had just finished a fast lap and is coasting around the track to come in to the pits between fast laps runs. Unfortunately, there is a very odd combination of missing fields from the data below. We are missing Sector 2 and Sector 3 information, which in turn leads to a missing LapTime. Fortunately, we can back into a derived lap time as you can probably see with our LapTime5 variable being populated below. 

<br/>

For this particular set of cases, we can start by subtracting Sector1SessionTime from PitInTime. While technically, using PitInTime means the time in which Lando enters the pits as opposed to crossing the start/finish line, this is the best we'll be able to do for this particular problem as well as there not being any harmful drawbacks in the few seconds difference for this particular analysis. Finally, since Sector1SessionTime is the time in which the driver *completed* the sector, we need to also subtract Sector1Time (the time spent in sector 1, as opposed to the time of completing the sector).

When we calculate: PitInTime: 1669.06 - (Sector1SessionTime: 1575.146 - Sector1Time: 19.763), we get our derived lap time in this case of 113.665 seconds. This is a very slow lap, denoting the time it took Lando Norris to get from the start/finish line to the pit lane entrance. 


```{r}

selected_lap_vars <- c("Sector1Time", "Sector2Time")

ad_quali_2021_l %>%
  select(Driver, DriverNumber, LapNumber, PitInTime, PitOutTime,
         Sector1SessionTime, Sector2SessionTime, Sector3SessionTime,
         Sector1Time, Sector2Time, Sector3Time, LapTime,
         LapTime5) %>%
    filter(if_any(all_of(selected_lap_vars), is.na)) %>%
  filter(Driver == "NOR" & LapNumber == 5) %>%
  kbl() %>%
  kable_styling(position = "center") # will need to trial and error this one once uploaded to blog


```

<br/>

For this next example, we've got a case that's a little more straightforward. This is a slow Out Lap by Valterri Bottas. This lap has populated data for sectors 2 and 3, with missing data for sector 1. This seems to be because of exiting the pit lane, which is somewhere near the middle of sector 1. Once again, this is an edge case in the data and we will treat these particular set of cases as if the exit of the pit lane is the beginning of these slow laps. We can get away with this because slow laps in F1 are generally very slow in comparison to fast laps - the few seconds "gained" from starting a drivers slow lap from the exit of the pit lane (which we know) instead of the start/finish line (which we don't know) will not hurt us for this analysis. 

Below, we can simply take the (Sector2SessionTime: 3351.012 - PitOutTime: 3274.034) to yield our sector 1 time of 30.85. Then we can take our derived Sector1Time: 30.85 + Sector2Time: 46.128 + Sector3Time: 71.12 to give us our calculated LapTime5 of 148.098. Another really slow lap, but we now at least have a lap time for it. 


```{r}

ad_quali_2021_l %>%
  select(Driver, DriverNumber, LapNumber, PitInTime, PitOutTime,
         Sector1SessionTime, Sector2SessionTime, Sector3SessionTime,
         Sector1Time, Sector2Time, Sector3Time, LapTime,
         LapTime5) %>%
    filter(if_any(all_of(selected_lap_vars), is.na)) %>%
  filter(Driver == "BOT" & LapNumber == 12) %>%
  kbl() %>%
  kable_styling(position = "center") # will need to trial and error this one once uploaded to blog

```


#### 2. Calculating qualifying sessions

I am going to bring back the plot from above, to dive into more details that I left out before. Before, I mentioned the separation in lap times from top to bottom on the y-axis. But if you look on the x-axis, for session progress, you'll notice that there are clear separations there as well. This leads us to our next section of data cleaning: for qualifying sessions - which we actually do not have data for in this dataset.

```{r, warning=FALSE, message=FALSE, fig.align='center', echo=FALSE}

ad_quali_2021_l %>%
  ggplot(aes(x = LapStartTime, y = LapTime)) +
  geom_point(color = "#5a0d9e",
             alpha = 0.6) +
  labs(title = "Abu Dhabi 2021 Qualifying, all laps from raw data",
       subtitle = "These red lines are where we know each session had ended by.",
       x = "Lap Start Time",
       y = "Lap Time") +
  scale_x_continuous() +
  sec_lab_convert(axis = "y",
                  int_sec = 10) +
  geom_vline(xintercept = 2500,
             color = "red",
             linetype = "dashed") +
  geom_vline(xintercept = 3800,
             color = "red",
             linetype = "dashed") +
  theme_main() +
  theme_main_add() 

```

- session break logic here

- need to add code to "detect" and create session number
  - if gap between laps is > 5 minutes, then flag for a new session and cumulative increment session numebr

<br/>

In Formula One, qualifying is done by way of elimination across three sessions. For the first session, all 20 drivers on the grid have 18 minutes to score as fast of a lap as possible. At the end of the first 18 minutes, the 5 drivers with the slowest lap times are eliminated, with their starting position set for the race. Session 2 features 15 minutes for the remaining 15 drivers to do the same thing again, until the next 5 drivers with the slowest lap times are eliminated before the final, 12 minute session featuring the remaining 10 drivers. 

Unfortunately, the data at-hand does not include data for the session number within qualifying. Because of this, we need to create logic to derive this so that we can then use it in our analysis. 

One key piece of information that we know is that each break, between the first and second qualifying sessions (referred to as Q1 and Q2) is at least five minutes long. Judging by F1 qualifying footage from the 2021 season, this timer begins once the track is clear from the ending session. This information allows us to store this as a variable in R (in seconds) and then proceed with our logic. 



```{r}

# breaks in between quali sessions are 300 seconds / 5 minutes

break_seconds <- 300

```


While the below code is a total blob of text, the important thing to know is that it creates session numbers for Abu Dhabi's qualifying session. This is done with the following assumptions in mind: That the only 5 minute periods without a lap completed in a qualifying session are the breaks in qualifying.

As a prelude for the rest of this data cleaning exercise, and for a spoiler for what the rest of the 2021 season's qualifyings look like - Abu Dhabi had a very clean qualifying session that holds this assumption. While there was a quick red flag during Abu Dhabi's qualifying, this was probably the quickest of the year to simply remove loose debris from the track near the end of the first session.

There were numerous qualifying sessions throughout the season that did not hold our key assumption above, which will need additional more-stringent and case-specific data cleaning (Part 2!). 

Things that worked for Abu Dhabi, but *could* not work for other qualifyings:

  - Red flags in qualifying ( more-prevalent in recent seasons) lasting more than 5 minutes
  - There always being two laps in a session within 5 minutes of each other

```{r}

quali_reference_data <- ad_quali_2021_l %>%
  mutate(Sector1Time_outlap = ifelse(!is.na(PitOutTime), (Sector2SessionTime-PitOutTime-Sector2Time), NA),
         # LapStartTime alone should not be used for this logic
         # use PitOutTime as LapStartTime for outlaps, LapStartTime for non-outlaps
         coal_LapStartTime = coalesce(PitOutTime, LapStartTime)) %>%
  arrange(coal_LapStartTime) %>% # this is important
  mutate(last_coal_LapStartTime = lag(coal_LapStartTime),
         last_coal_LapStartTime_delta = (coal_LapStartTime - last_coal_LapStartTime),
         session_break_flag_coal = ifelse(last_coal_LapStartTime_delta >= break_seconds, 1, 0)) %>%
  fill(session_break_flag_coal, .direction = "up") %>%
  mutate(session_number_coal = as.factor(as.character((cumsum(session_break_flag_coal) + 1)))) %>%
  # dont think the below LapStartTime session breaks will be needed
  arrange(LapStartTime) %>% # this is important
  mutate(last_LapStartTime = lag(LapStartTime),
         last_LapStartTime_delta = (LapStartTime - last_LapStartTime),
         # have to control here for cases where there may be > 5 min pause because of red flags (TrackStatus: 5)
         # session_break_flag = ifelse((TrackStatus != "5" & last_LapStartTime_delta) >= break_seconds, 1, 0),
         session_break_flag = ifelse(last_LapStartTime_delta >= break_seconds, 1, 0),
         session_break_flag2 = session_break_flag) %>%
  fill(session_break_flag2, .direction = "up") %>%
  mutate(session_number = as.factor(as.character((cumsum(session_break_flag2) + 1)))) %>% # filter(Driver %in% c("SAI", "LEC", "GIO"))
  select(-c(last_coal_LapStartTime, last_coal_LapStartTime_delta,
            session_break_flag_coal, last_LapStartTime, last_LapStartTime_delta, 
            session_break_flag, session_break_flag2)) # removing all columns that were added
  
```

Above, we created an additional variable / column in our dataset for session number. Now that this variable is created, we can validate that its behavior matches what we expect - shown below by creating a summary table of this new session number variable.

Below, we can see that - for each session - we can calculate the number of unique drivers, earliest and latest times in which a lap started, and if there was a red flag (1:yes, 0:no). According to our summary table, we've got 20 drivers in Q1, 15 in Q2, and 10 in Q3, along with at least 5 minutes (300 seconds) between the highest lap start time in Q1 and lowest lap start time in Q2, .etc. Everything looks good on the surface. 


```{r}

# aggregate to impute quali session start times

quali_reference_agg_coal <- quali_reference_data %>%
  group_by(session_number_coal) %>%
  summarize(dis_Drivers = n_distinct(Driver),
            min_coal_LapStartTime = min(coal_LapStartTime),
            max_coal_LapStartTime = max(coal_LapStartTime),
            max_RedFlag = max(ifelse(TrackStatus == "5", 1, 0)))

# view 

quali_reference_agg_coal %>%
  # making names more interpretable
  rename("SessionNumber" = "session_number_coal",
         "Num_of_Drivers" = "dis_Drivers",
         "min_Session_LapStartTime" = "min_coal_LapStartTime",
         "max_Session_LapStartTime" = "max_coal_LapStartTime",
         "RedFlag" = "max_RedFlag") %>%
  kbl() %>%
  kable_styling(position = "center")

```


```{r}

ad_quali_2021_l <- ad_quali_2021_l %>%
  fuzzyjoin::fuzzy_join(quali_reference_agg_coal,
                    by = c("coal_LapStartTime" = "min_coal_LapStartTime",
                           "coal_LapStartTime" = "max_coal_LapStartTime"),
                    match_fun = list(`>=`, `<=`))

```


Now we can take all of the work that we have done to clean our data to this point and plot every lap along with separating these laps by the new session number variable that we derived.

```{r, warning=FALSE, message=FALSE, fig.align='center'}

ad_quali_2021_l %>%
  ggplot(aes(x = coal_LapStartTime, y = LapTime5)) +
  geom_point(color = "#5a0d9e",
             alpha = 0.6) +
  labs(title = "Abu Dhabi 2021 Qualifying, all laps from raw data",
       subtitle = "All laps, separated by qualifying session number",
       x = "Lap Start Time",
       y = "Lap Time") +
  coord_cartesian(ylim = c(80,190)) +
  scale_x_continuous() +
  sec_lab_convert(axis = "y") +
  facet_wrap(~session_number_coal,
             nrow = 1,
             scales = "free_x") +
  theme_main() +
  theme_main_add() 


```


Above we have been able to look at laps individually, as the qualifying session progresses, but what can we actually get out of that? Not too much, with that plot at face value. One thing is definitely clear in that there is a large separation / high variance in individual laps. There is a high density of laps between 1M 20S and 1M 30S and many laps that are clearly separated from the fastest set of laps from roughly 1M 35S and higher. 

We can summarize these lap times in a histogram for the entire qualifying session to visualize this a bit better. In the histogram, we can see two definite peaks in the distribution. The first peak that stands out is the stark number of laps that we can group together in the 1M 20S - 1M 25S range. The other peak is a more-gradual, less-dense peak that contain much slower lap times.


```{r, fig.align='center', fig.height=5.5, fig.width=10, warning=FALSE, message=FALSE}

# p_ad_all_laps <- 
ad_quali_2021_l %>%
  # filter(is.na(PitOutTime),
  #        is.na(PitInTime)) %>%
  ggplot(aes(y = LapTime5)) +
  geom_histogram(fill = "purple",
                 color = "black",
                 bins = 100) +
  labs(title = "Qualifying Lap Times Distribution",
       subtitle = "Abu Dhabi 2021, all sessions",
       x = "Ct. Laps",
       y = "Lap Time",
       color = "Tire") +
  coord_cartesian(ylim = c(80,190)) +
  # scale_x_continuous(breaks = seq(0,20,1)) +
  sec_lab_convert(axis = "y") +
  # facet_wrap(~as.factor(session_number_coal),
  #            scales = "free_x") +
  geom_hline(aes(yintercept = mean(LapTime4)),
             linetype = "dashed",
             color = "red") +
  theme_main() +
  theme_main_add()


```

What we see here is the effect of drivers taking their slow laps versus their fast laps. Drivers stints during their qualifying runs most-often consistent with the following pattern:

1. Driver exits the pit lane and continues on a slow Out Lap
  - A driver's Out Lap routine is dependent on the circuit and the abrasiveness of the asphalt. A driver may nearly coast during their Out Lap to not cause needless and excessive tire wear on abrasive (Ex: Silverstone) or particularly long circuits (Ex: COTA) or, less often, they may opt to vigorously warm up their tires or even take multiple Out Laps on tracks friendlier to tires (Ex: Portim√£o). This is all part of the balance that teams need to find at each circuit.

2. Fast Lap begins once the driver makes it around the track and to the start / finish line, puts in full effort pushes the car to the limit
  - At very niche tracks, such as Monaco, drivers may do multiple fast laps - but this is very rare throughout the season as a whole

3. After a driver's fast lap(s), they'll begin their In Lap which is a slow trek around the circuit and back into the pit lane and then the garage to refuel and change tires, if desired

Since we are looking to purely look to measure how much faster *Fast* Laps are getting throughout qualifying sessions, we need to design a way to efficiently predict to a reasonably-accurate degree if a lap as a Fast Lap or a Slow Lap. Consistent with the session number work above, the dataset we are using does not tell us if a driver is on a Fast Lap or not. This interpretation between Fast and Slow laps is also something that can be subjective, which I will detail later on. 


### Clustering

In order to lay the groundwork for my idea on predicting a Fast Lap vs. a Slow lap, let's look at a specific set of laps by Max Verstappen. This set of four laps was a stint from Verstappen's qualifying to begin Q2. Recalling our derived variable for lap times, LapTime5, we can see that the data shows a slow Out Lap, a fast lap, a slow lap, and the sting ends with a slow, In Lap. They key note here is the definite separation between Verstappen's fast lap at 83.189 seconds that are all over 100 seconds. Assuming that there is this kind of separation in time between most slow laps and fast laps, we should be able to predict for these using the right tools. 


```{r}

ad_VER_focus_laps <- ad_quali_2021_l %>%
  select(Driver, DriverNumber, LapNumber, PitInTime, PitOutTime,
         Sector1SessionTime, Sector2SessionTime, Sector3SessionTime,
         Sector1Time, Sector2Time, Sector3Time, LapTime,
         LapTime5) %>%
  mutate(ver_focus_flag = "1") %>%
  dplyr::filter(Driver == "VER",
                between(LapNumber, 7, 10)) 


ad_VER_focus_laps %>%
  kbl() %>%
  kable_styling(position = "center") # will need to trial and error this one once uploaded to blog

```


The plot below shows where these three laps fit in to Verstappen's entire qualifying session. Note the sheer separation between the laps just higher than the 1M 20S mark compared to every other lap: 

```{r, warning=FALSE, message=FALSE, fig.align='center'}

ad_quali_2021_l %>%
  left_join(ad_VER_focus_laps %>% select(Driver, LapNumber, ver_focus_flag),
            by = c("Driver" = "Driver",
                   "LapNumber" = "LapNumber")) %>%
  mutate(ver_focus_flag = ifelse(!is.na(ver_focus_flag), "Yes", "No"),
         ver_focus_flag = factor(ver_focus_flag, levels = c("Yes", "No"))) %>%
  dplyr::filter(Driver == "VER") %>%
  ggplot(aes(x = coal_LapStartTime, y = LapTime5, color = ver_focus_flag)) +
  geom_point(#color = "#5a0d9e",
             alpha = 1,
             size = 2) +
  labs(title = "Abu Dhabi 2021 Qualifying, Verstappen laps",
       subtitle = "All laps, Colored by Focus Laps",
       x = "Lap Start Time",
       y = "Lap Time",
       color = "Focus Laps?") +
  # coord_cartesian(ylim = c(80,190)) +
  scale_x_continuous() +
  sec_lab_convert(axis = "y") +
  facet_wrap(~session_number_coal,
             nrow = 1,
             scales = "free_x") +
  theme_main() +
  theme_main_add() 


```


This brings us to the topic of **clustering**, a family of predictive models that we will explore to differentiate fast laps from slow laps. As a brief overview, in the machine learning realm there are many predictive models to use depending on the goal. These predictive models can be categorized between two types: Supervised and Unsupervised. 

Supervised models are used when there is tangible data that exists for a dependent variable to predict for. An example of this could be having a dataset of wine ratings from a website with facts and attributes of those wines. In that case, wine ratings would be the dependent variable and we would have that not only to predict for, but also be able to directly know the accuracy / strength of the model created.

Our dataset does not have data for a fast or slow "Lap Type", which is what we're interested in knowing. Because of this, we will use Unsupervised modeling to derive "Lap Type". 

First, it's important to think about which laps we actually need to put effort into differentiating between fast and slow. The only laps that we're interested in classifying are laps that are **not** In Laps or Out Laps. Below, we separate our laps before anything else to show a better picture on a smaller subset of laps that will actually get categorized:

```{r, fig.align='center', fig.height=5.5, fig.width=10, warning=FALSE, message=FALSE}

ad_quali_2021_l <- ad_quali_2021_l %>%
  mutate(could_cluster = ifelse(is.na(PitOutTime) & is.na(PitInTime), "To Cluster", "Dont Cluster"),
         could_cluster = factor(could_cluster, levels = c("To Cluster",
                                                          "Dont Cluster")))

# viz: splitting out relevant laps

ad_quali_2021_l %>%
  # filter(is.na(PitOutTime),
  #        is.na(PitInTime)) %>%
  ggplot(aes(y = LapTime5, fill = could_cluster)) +
  geom_histogram(color = "black",
                 bins = 100,
                 show.legend = FALSE) +
  labs(title = "Qualifying Lap Times Distribution",
       subtitle = "Abu Dhabi 2021, all sessions",
       x = "Ct. Laps",
       y = "Lap Time",
       caption = "Data: FastF1") +
  sec_lab_convert(axis = "y") +
  coord_cartesian(ylim = c(60, 200)) +
  facet_wrap(~could_cluster,
             nrow = 1) +
  scale_fill_manual(values = c("To Cluster" = "#7a00f5",
                               "Dont Cluster" = "#ab511d")) +
  theme_main() +
  theme_main_add()

```

Here is a visualization of our goal: to separate laps in the "To Cluster" category between what we believe to be Fast Laps (below the dotted red line) from what we believe to be Slow Laps (above the dotted red line). This particular red line was manually placed there by me, but it represents what we're trying to replicate. Using a form of clustering known as [single-linkage Hierarchical Clustering](https://www.analyticsvidhya.com/blog/2021/06/single-link-hierarchical-clustering-clearly-explained/), we are looking for the point for the two laps with the most seconds between them and then using that point as our boundary for classifying Fast vs. Slow laps.

```{r, fig.align='center', fig.height=5.5, fig.width=10, warning=FALSE, message=FALSE}

ad_quali_2021_l %>%
  # mutate(hclust = as.character(hclust),
  #        hclust = case_when(is.na(hclust) ~ "NA",
  #                           TRUE ~ as.character(hclust))) %>%
  # filter(is.na(PitOutTime),
  #        is.na(PitInTime)) %>%
  ggplot(aes(y = LapTime5, fill = could_cluster)) +
  geom_histogram(# fill = "purple",
                 color = "black",
                 bins = 100,
                 show.legend = FALSE) +
  labs(title = "Can we (automatically) create two segmentations for laps split by this red line?",
       subtitle = "Abu Dhabi 2021, all sessions",
       x = "Ct. Laps",
       y = "Lap Time",
       color = "",
       caption = "Data: FastF1") +
  # scale_x_continuous(breaks = seq(0,20,1)) +
  sec_lab_convert(axis = "y") +
  coord_cartesian(ylim = c(60, 200)) +
  # facet_wrap(~as.factor(session_number_coal),
  #            scales = "free_x") +
  geom_hline(aes(yintercept = ifelse(could_cluster == "To Cluster", 93, NA),
                 group = raceName,
                 color = "Attempted cutoff"),
                 linetype = "dashed",
             size = 1.5) +
  facet_wrap(~could_cluster,
             nrow = 1) +
  scale_color_manual(values = c("Attempted cutoff" = "red")) +
  scale_fill_manual(values = c("To Cluster" = "#7a00f5",
                               "Dont Cluster" = "#ab511d")) +
  # scale_fill_manual(values = c("1" = "#b81f4f",
  #                              "2" = "#8400f0",
  #                              "NA" = "#8a8a8a")) +
  theme_main() +
  theme_main_add()

```

So let's create our clustering model.
First, we remove any laps that are either In Laps or Out Laps:
  
```{r}

# hclust code here (non-function?)

# create filtered data

exclude = c("InLap_flag", "OutLap_flag")
exclude_list <- do.call(paste0, list(exclude))

ad_quali_2021_l_clust <- ad_quali_2021_l %>%
  filter(if_all(all_of(exclude_list), ~ . == "0")) %>%
  select(Driver, LapNumber, LapTime5)

```

Then we use the **hclust()** function to create our hierarchical clustering model based off of LapTime5 only, and additionally designate this as a single-linkage model by using the *method = "single"* argument. We specify the number of clusters that we want to create with *cutree(2)*, one cluster for fast laps and one for slow laps. In our data, our clusters are stored in a variable named: *hclust*. In the last part of the code below, we join our cluster variable to our main dataset of Abu Dhabi qualifying laps - ad_quali_2021_l - that we've been working with for most of this project so far. 

<br/>

From here on:

  - Cluster 1 will be our fast laps
  - Cluster 2 will be our slow laps
  - Cluster NA will be laps that were either In Laps, Out Laps, or laps aborted in sector 3
  
<br/>

```{r}
  
# create hclust on filtered data

ad_quali_2021_l_clust$hclust <- ad_quali_2021_l_clust %>%
  select(LapTime5) %>%
  dist() %>%
  hclust(method = "single") %>%
  cutree(2) %>%
  factor()

# join filtered data onto raw data

ad_quali_2021_l <- ad_quali_2021_l %>%
  left_join(select(ad_quali_2021_l_clust, -LapTime5), by = c("Driver", "LapNumber"))

```

Now we can return to our set of 4 Verstappen laps in Q2 and look at our hclust variable within the data. The two In Laps / Out Laps are shown as NA, the slow non-In Lap / Out Lap was predicted to be in cluster 2, with the much faster lap being predicted to be in cluster 1. 

```{r}

ad_VER_focus_laps <- ad_quali_2021_l %>%
  select(Driver, DriverNumber, LapNumber, PitInTime, PitOutTime,
         Sector1SessionTime, Sector2SessionTime, Sector3SessionTime,
         Sector1Time, Sector2Time, Sector3Time, LapTime,
         LapTime5, hclust) %>%
  mutate(ver_focus_flag = "1") %>%
  dplyr::filter(Driver == "VER",
                between(LapNumber, 7, 10)) 


ad_VER_focus_laps %>%
  kbl() %>%
  kable_styling(position = "center") # will need to trial and error this one once uploaded to blog

```

### Aborted Laps

Not all fast laps are "Fast Laps". 

```{r, eval=TRUE, echo=TRUE}

# revisit this tomorrow... need to add session break logic first..

# session breaks havent been created yet, will need to walk through that before clustering
## even in analysis, clusters are the last thing created in data cleaning step

ad_quali_2021_l_clust1 <- ad_quali_2021_l %>%
  # debug, remove
  # dplyr::select(Driver, LapNumber, session_number_coal_f, PitInTime, PitOutTime, Sector3Time, scale_Sector3Time, LapTime5, hclust) %>%
  # filter(Driver == "VER") %>% # VER, LapNumber 18 should not be NA.. actually, yes it should.. aborted lap at end
  # debug, remove
  filter(hclust == 1) %>%
  select(season, raceName,Driver, DriverNumber, LapNumber, session_number_coal, lap_start_rownum, Compound, hclust, LapTime5, Sector3Time) %>%
  mutate(scaled_Sector3Time = scale(Sector3Time)) %>%
  # cant do aborted lap logic until here, after filtering to only fast laps
  # aborted lap logic
  group_by(season, raceName, Driver, Compound) %>%
  arrange(season, raceName, Driver, Compound, lap_start_rownum) %>%
  mutate(last_driver_compound_LapTime5 = lag(LapTime5),
         last_driver_compound_delta_sec = (LapTime5 - last_driver_compound_LapTime5),
         last_driver_compound_delta_pct = ((LapTime5 - last_driver_compound_LapTime5) / last_driver_compound_LapTime5)) %>%
  ungroup() %>%
  arrange(DriverNumber, Compound, lap_start_rownum) %>%
  # have to explicitly keep NAs here
  # remove any lap that is > 1% increase from previous lap on same compound (assuming outliers, not assoc. w/ track evo)
  # could also flag and then compare with and without.. 
  filter(is.na(last_driver_compound_delta_pct) | last_driver_compound_delta_pct <= .01) %>%
  filter(is.na(scaled_Sector3Time) | scaled_Sector3Time < 3) %>%
  ungroup() %>%
  mutate(hclust1_final = hclust) %>% # think i can remove this
  select(Driver, LapNumber, hclust1_final)


#

ad_quali_2021_l <- ad_quali_2021_l %>%
  left_join(ad_quali_2021_l_clust1, by = c("Driver", "LapNumber")) %>%
  mutate(hclust = ifelse(hclust == 1 & is.na(hclust1_final), NA, hclust),
         hclust = as.factor(as.character(hclust)))

```

  
<br/>

### 

So finally, we can create a plot that encompasses all of the work above, that:

1. Shows all available lap times, even those that have missing sector times or otherwise incomplete data
2. Groups the laps by the session number they came in
3. Classifies laps by the created clusters, denoting fast (cluster 1) laps from slow laps (cluster 2) and In Laps / Out Laps (Cluster NA) laps


```{r, fig.align='center', fig.height=5.5, fig.width=7.5, warning=FALSE, message=FALSE}

ad_quali_2021_l %>%
  mutate(hclust = case_when(is.na(hclust) ~ "NA",
                            TRUE ~ as.character(hclust))) %>%
  ggplot(aes(x = coal_LapStartTime, y = LapTime5, color = hclust)) +
  geom_point(size = 2,
             alpha = 0.6) +
  labs(title = "Abu Dhabi 2021 Qualifying, all laps from cleaned data",
       subtitle = "Grouped by our created clusters and separated by session number!",
       x = "Lap Start Time",
       y = "Lap Time",
       color = "Cluster") +
  coord_cartesian(ylim = c(70,180)) +
  scale_x_continuous() +
  sec_lab_convert(axis = "y") +
  scale_color_manual(values = c("1" = "#b81f4f",
                                "2" = "#8400f0",
                                "NA" = "#8a8a8a")) +
  facet_wrap(~session_number_coal,
             nrow = 1,
             scales = "free_x") +
  theme_main() +
  theme_main_add() 

```

<br/>

So let's think about this, we've now gotten to a point where we can look at **only** the fast laps from a qualifying session. Theoretically, if we were to begin an analysis now, we would almost certainly still see a decrease in overall lap times as the session progressed - but there is one variable still to account for: Car Strength.

<br/>

(As I alluded to in the intro...) A nuance about Formula One compared to most, particularly American, sports is that there is historically very-little parity between the top teams and the bottom teams. So while, in the plot below, we see lap times decreasing from session 1-3, this *could* be due to track evolution or it could also be that the average performance of the cars remaining in Q3 are always going to be better than the cars in session participating in Q1. This brings up a problem of collinearity, which is a term in statistics used to describe multiple independent variables being associated with each other. So what does that mean? If we have track evolution decreasing lap times, and we have the general, increasing strength of the field decreasing lap times, then being able to measure the effect that those two variables, individually, have on decreasing lap times becomes more difficult. 


```{r, fig.align='center', fig.height=5.5, fig.width=7.5, warning=FALSE, message=FALSE}

ad_quali_2021_l %>%
  filter(hclust == 1) %>%
  ggplot(aes(x = coal_LapStartTime, y = LapTime5, color = hclust)) +
  geom_point(show.legend = FALSE) +
  geom_smooth(method = "gam",
              show.legend = FALSE) +
  labs(title = "Abu Dhabi 2021 Qualifying Lap Times by Session Progress",
       subtitle = "Fast laps only, all drivers",
       x = "Lap Start Time",
       y = "Lap Time",
       color = "Cluster") +
  scale_x_continuous() +
  sec_lab_convert(axis = "y",
                  start_sec = 70,
                  end_sec = 150,
                  int_sec = 1) +
  scale_color_manual(values = c("1" = "#7a00f5",
                                "2" = "#ab511d")) +
  theme_main() +
  theme_main_add() 

```

<br/>

For this analysis, we will deal with this case by analyzing the laps of only drivers that ended up making it to Q3. With this, the strength of the field is constant across all sessions and all laps being analyzed will be from drivers that drove in the each of the three sessions. One thing to note, however, is that in doing this we do make our already-small sample of relevant laps even smaller.

```{r}

# grabbing the drivers who advanced to Q3 during qualifyinh

ad_compile_q3_drivers <- ad_quali_2021_l %>%
  # filter(raceName == "Abu Dhabi Grand Prix") %>%
  # select(raceName, Driver, session_number_coal2) %>%
  select(raceName, Driver, session_number_coal) %>%
  group_by(raceName, Driver) %>%
  # summarize(max_session = max(as.numeric(as.character(session_number_coal2))),
  #           .groups = "drop") %>%
  summarize(max_session = max(as.numeric(as.character(session_number_coal))),
            .groups = "drop") %>%
  filter(max_session == 3)

```


```{r}

# filtering on drivers who made Q3 via inner join
# then. filtering explicitly on only fast laps (hclust == 1)

ad_quali_2021_l_fast_compile <- ad_quali_2021_l %>%
  inner_join(ad_compile_q3_drivers, by = c("Driver" = "Driver",
                                           "raceName" = "raceName")) %>%
  filter(hclust == 1)

```


Below is a plot visualizing the relevant laps in this analysis: fast laps for drivers that made it through to Q3:

```{r, fig.align='center', fig.height=5.5, fig.width=7.5, warning=FALSE, message=FALSE}

ad_quali_2021_l_fast_compile %>%
  ggplot(aes(x = coal_LapStartTime, y = LapTime5, color = hclust)) +
  geom_point(show.legend = FALSE) +
  geom_smooth(method = "gam",
              show.legend = FALSE) +
  labs(title = "Abu Dhabi 2021 Qualifying Lap Times by Session Progress",
       subtitle = "Fast laps only, Drivers that advanced to Q3",
       x = "Lap Start Time",
       y = "Lap Time",
       color = "Cluster") +
  scale_x_continuous() +
  sec_lab_convert(axis = "y",
                  start_sec = 70,
                  end_sec = 150,
                  int_sec = 1) +
  scale_color_manual(values = c("1" = "#7a00f5",
                                "2" = "#ab511d")) +
  theme_main() +
  theme_main_add() 

```


<br/>

Finally, we are done preparing our data and can move on to analyzing track evolution.
In the plot above, we can see a trend downwards in lap times for the drivers that participated in all three sessions. Generally speaking, it looks like lap times decreased between around 0.75 seconds to 1 second on average from the start of qualifying to the end. 

<br/>

## Analysis
  
Now it's time to build a statistical model. For a descriptive analysis like this - where we're not necessarily interested in predicting outcomes, but rather to describe and measure the patterns, trends, and behaviors that the data contains - there are a variety of models we can use to do so. Ideally we are looking for a model that's simple enough to interpret and explain, but possesses the ability to capture any non-linear trends that come up in our small data.

Generalized Additive Models (GAM) are a great candidate to solve for these needs as they have more flexibility (no pun intended) compared to linear models - thanks to their usage of what's called basis functions, but are also relatively-interpretable compared to black box machine learning algorithms.


```{r}

ad_q3_driver_gam <- mgcv::gam(LapTime5 ~ s(lap_start_rownum, by = Compound) + Compound + Team,
                              data = ad_quali_2021_l_fast_compile, method = "REML")


```


#### Modeling over observed data

```{r}

# modeling over observed data

ad_q3_driver_preds <- broom::augment(ad_q3_driver_gam, data = ad_quali_2021_l_fast_compile) %>% 
  select(DriverNumber, Driver, LapNumber, lap_start_rownum, Compound, Team,
         session_number_coal, LapTime5, .fitted, .se.fit, .resid) %>%# View()
  mutate(lower = .fitted - 1.96 * .se.fit,
         upper = .fitted + 1.96 * .se.fit)

```

Here we can see a 6 row preview of the "observed" data used for model training. Using the augment function from the broom package, the model is fit to the observed data. This function also creates a series of model fit columns attached to the end of the dataset: **.fitted, .se.fit, .resid, lower, upper**.

```{r}

ad_q3_driver_preds %>%
  head() %>%
  kbl() %>%
  kable_styling(position = "center")

```

Below is a visualization of the fit of the GAM model for Abu Dhabi qualifying. The laps and any usage of model outputs for laps under medium tires will all but be thrown away, but it's still kind of interesting to see the difference in lap time for teams that use both the soft and medium compound tires. 

```{r, fig.align='center', fig.height=5.5, fig.width=10, warning=FALSE, message=FALSE}

# plot: model over observed data

ad_q3_driver_preds %>%
  ggplot(aes(x = lap_start_rownum, y = LapTime5, color = Compound)) +
  geom_point() +
  # geom_smooth(method = "gam") +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
  geom_line(aes(x = lap_start_rownum, y = .fitted, group = Compound), color = "purple") +
  labs(title = "Lap Time Predictions per Session Progress, Team, Tire Compound",
       subtitle = "Abu Dhabi Grand Prix Qualifying, Drivers who made Q3 only",
       x = "Laps Started",
       y = "Lap Time") +
  sec_lab_convert(axis = "y",
                  start_sec = 60,
                  end_sec = 180,
                  int_sec = 0.5) +
  facet_wrap(~fct_reorder(Team, -LapTime5),
             nrow = 1) +
  scale_color_manual(values = c("SOFT" = "RED",
                                "MEDIUM" = "#e3a600")) +
  theme_main() +
  theme_main_add()


```


#### Modeling over predicted data

The final step for modeling Abu Dhabi qualifying is to create a final dataframe to apply the trained model on. For that, we create a new dataset for soft compound tires only - featuring as many laps per team as were run throughout the entire qualifying session.


```{r}

ad_max_laps_team_data <- ad_quali_2021_l_fast_compile %>%
  select(season, raceName, Team, lap_start_rownum) %>%
  group_by(season, raceName, Team) %>%
  summarize(min_lap_start_rownum = min(lap_start_rownum),
            start_session = 1, # dont think i need this
            max_lap_start_rownum = max(lap_start_rownum)) %>%
  ungroup() 


fit_predict_df <- ad_max_laps_team_data %>%
  group_by(season, raceName) %>%
  expand(Team,
         lap_start_rownum = 1:max(max_lap_start_rownum),
         Compound = "SOFT") %>%
  ungroup()

fit_predict_df %>% head()

```


The GAM model is then fitted to the new dataset and outputs fitted lap times for each team regardless of when they actually ran laps in qualifying. In doing so, this gives us fairly large confidence bands for the laps in which a team did not have a lap ran, for example: Ferrari who used medium compound tires at the beginning of qualifying for some reason. Since the model was trained with both session progress and tire compounds in mind *per team*, there can still be a lap time fitted with reduced confidence in its accuracy.

```{r}

ad_fit_predict_preds <- broom::augment(ad_q3_driver_gam, newdata = fit_predict_df) %>% 
  # select(DriverNumber, Driver, LapNumber, lap_start_rownum, Compound, Team,
  #        session_number_coal, LapTime5, .fitted, .se.fit, .resid) %>%# View()
  mutate(lower = .fitted - 1.96 * .se.fit,
         upper = .fitted + 1.96 * .se.fit)

```

The plot below shows that, as a whole, Mercedes was consistently faster throughout qualifying. However, Red Bull's Max Verstappen had the fastest lap of the session which came with help from a tow by his teammate Sergio Perez.

```{r, fig.align='center', fig.height=5.5, fig.width=10, warning=FALSE, message=FALSE}

# plot: model over predicted data

ad_fit_predict_preds %>%
  ggplot(aes(x = lap_start_rownum, y = .fitted)) +
  geom_point(data = ad_q3_driver_preds %>%
                      filter(Compound == "SOFT"),
             aes(x = lap_start_rownum, y = LapTime5,
                 color = Driver)
             ) +
  # geom_line(data = quali_gam_df %>%
  #              unpack_safely(col = "preds_obs",
  #                            data_to_keep = c("Driver", "TrackStatus")) %>%
  #             filter(raceName == gp_select) %>%
  #              filter(Compound == "SOFT"),
  #            aes(x = lap_start_rownum, y = LapTime5, color = Driver), alpha = 0.5) +
  geom_line(color = "red") +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
  labs(title = "Lap Time Predictions over Session Progress",
       subtitle = "Abu Dhabi Grand Prix Qualifying, Drivers who made Q3 only",
       x = "Laps Started",
       y = "Lap Time") +
  sec_lab_convert(axis = "y",
                  start_sec = 60,
                  end_sec = 180,
                  int_sec = 0.5) +
  facet_wrap(~fct_reorder(Team, -.fitted),
             nrow = 1) +
  theme_main() +
  theme_main_add()

```


Now, it should be said that a GAM wasn't needed to be able to come to the conclusion above. What we can do is summarize the GAM model outputs for tracks as a whole and then compare track evolution that was seen across tracks in 2021.

For starters, according to the Abu Dhabi GAM model, there was about a 1.2% decrease in lap times for drivers that made Q3 from the beginning to the end. Creating a model per track will let us compare respective decreases in lap times throughout (most of) the entire season.  

```{r, fig.align='center', fig.height=5.5, fig.width=10, warning=FALSE, message=FALSE}

ad_quali_gam_pred_agg <- ad_fit_predict_preds %>%
  # unpack_safely(col = "preds_new",
  #               add_conf = TRUE,
  #               data_to_keep = c("Driver", "TrackStatus")) %>% 
  group_by(raceName, lap_start_rownum) %>%
  summarize(raceName_mean_fitted = mean(.fitted)) %>%
  group_by(raceName) %>%
  mutate(raceName_first_fitted = first(raceName_mean_fitted),
         raceName_last_fitted = last(raceName_mean_fitted),
         mean_pct_decrease_evo = ((raceName_first_fitted - raceName_mean_fitted) / raceName_first_fitted),
         raceName_last_laps_start_rownum = last(lap_start_rownum),
         pct_raceName_laps = (lap_start_rownum / raceName_last_laps_start_rownum)) %>%
  ungroup()


ad_quali_gam_pred_agg %>%
  ggplot(aes(x = lap_start_rownum, y = mean_pct_decrease_evo,
             color = raceName)) +
  geom_line(show.legend = FALSE) +
  # geom_point() +
  labs(title = "Average Decrease in Lap Times per Qualifying Session",
       subtitle = "Abu Dhabi Qualifying 2021, Average lap time delta per team",
       x = "Laps Started",
       y = "% Decrease in Lap Times (mean)",
       color = "Race") +
  scale_x_continuous() +
  scale_y_reverse(labels = scales::percent_format(accuracy = 0.01)) +
  theme_main() + 
  theme_main_add()

```

<br/>

## Parameterizing: Fitting many models

For this section, I am not going to be posting as much of the code that produces the result below. The main concepts of the code are all above, but those concepts have been taken and turned into functions and reproducible R code so that we can apply that code to each qualifying session throughout the year.

That code lives [within my Github repo here.](https://github.com/renville-colin/f1_track_evo/blob/main/f1_track_evo_expand.Rmd)


```{r, echo=FALSE, message=FALSE, warning=FALSE}

# need to turn this into a function
## also need to ensure that coal_LapStartTime gets created as seen in get_quali_reference()

clean_lap_data <- function(tbl) {
  
  # debug
  # tbl <- get_driver_data(season = '2021',
  #                        # circuit = 'Abu Dhabi',
  #                        circuit = 'americas',
  #                        session = 'Q',
  #                        driver = 'ALL',
  #                        data_type = 'laps')
  # tbl <- lap_data_raw
  
  lap_clean_df <- tbl %>%
    # prune out what isnt being used below
    # arrange(LapStartTime) %>%
    group_by(Driver) %>%
    mutate(Compound = factor(Compound, levels = c("SOFT", "MEDIUM", "HARD")),
           LapTime_per = seconds_to_period(LapTime),
           next_lap_StartTime = lead(LapStartTime),
           Sector1SessionTime2 = (next_lap_StartTime - (Sector2Time + Sector3Time)),
           Sector1Time3 = (next_lap_StartTime - PitOutTime - Sector2Time - Sector3Time),
           Sector3Time2 = (PitInTime - Sector2SessionTime),
           LapTime4 = coalesce(LapTime,
                               (Sector1Time + Sector2Time + Sector3Time),
                               (Sector1Time3 + Sector2Time + Sector3Time)),
           Sector1Time_outlap = ifelse(!is.na(PitOutTime), (Sector2SessionTime-PitOutTime-Sector2Time), NA),
           # LapStartTime alone should not be used for this logic
           # use PitOutTime as LapStartTime for outlaps, LapStartTime for non-outlaps
           coal_LapStartTime = coalesce(PitOutTime, LapStartTime),
           LapTime5 = coalesce(LapTime4,
                              (PitInTime - LapStartTime) # for laps occuring during a red flag
                              ),
           InLap_flag = if_else(!is.na(PitInTime), 1, 0),
           OutLap_flag = if_else(!is.na(PitOutTime), 1, 0),
           coal_Sector1Time = coalesce(Sector1Time, Sector1Time3),
           coal_Sector3Time = coalesce(Sector3Time, Sector3Time2)) %>%
    ungroup() %>%
    group_by(season, raceName) %>%
    mutate(lap_start_rownum = (dplyr::row_number(coal_LapStartTime) - 1),
           scale_LapTime5 = scale(LapTime5)) %>%
    ungroup()
  
  # editing below... 
  
  lap_clean_scaled <- lap_clean_df %>%
    # any filtering that gets added to hclust_exlude() needs to be replciated here
    filter(InLap_flag == 0 & OutLap_flag == 0) %>%
    select(raceName, season, Driver, DriverNumber, LapNumber, InLap_flag,
           OutLap_flag, coal_Sector1Time, Sector2Time, coal_Sector3Time,
           LapTime5, scale_LapTime5) %>%
    mutate(scale_Sector1Time = scale(coal_Sector1Time),
           scale_Sector2Time = scale(Sector2Time),
           scale_Sector3Time = scale(coal_Sector3Time),
           scale_LapTime5_filtered = scale(LapTime5)) %>%
    select(-c(Driver, LapTime5, InLap_flag, OutLap_flag, coal_Sector1Time, Sector2Time,
              coal_Sector3Time, scale_LapTime5))
  
  # rejoin scaled, filtered data onto primary df
  
  lap_clean_df <- lap_clean_df %>%
    left_join(lap_clean_scaled, by = c("season" = "season",
                                       "raceName" = "raceName",
                                       "DriverNumber" = "DriverNumber",
                                       "LapNumber" = "LapNumber"))
  
  return(lap_clean_df)
  
}


# for quali sessions, will need to establish a reference table for session number
## Q1 if lap before Q2, Q2 if lap started after Q1 and before Q3, .etc
## will need to loop through all drivers qualifying laps
## floor start of first lap to nearest hour for session start then, calculate intervals off of that

# easier to do the above (as it is built now); or
# just pass a df as arg and add session_number to existing df
## to avoid calling get_driver_data() more than once
## would assume scope of analysis stays within a single gp weekend
# keeping it as is allows is more expensive but does allow to be more creative
## data is also cached locally, so not hurting anything


get_quali_reference_tbl <- function(tbl) {
  
  # pick up tomorrow: zandvoort only has 2 sessions.. where in here is that a problem? / why?
  
  # season = '2021'
  # circuit = 'Spanish Grand Prix'
  # session = 'Q'
  # driver = 'ALL'
  # data_type = 'laps'
 
  # tbl <- get_driver_data(season,
  #                        circuit,
  #                        session,
  #                        driver,
  #                        data_type) %>%
  #     clean_lap_data()
  
  
  # breaks in between quali sessions are 300 seconds / 5 minutes
  
  break_seconds <- 300
  
  session_min_ref <- tibble("session" = c(1,2,3),
                            "min_length" = c(18, 15, 12))
  
  # plan: when one of these laps occur, trigger another session;
  ## flag and then increment session_break_flag_coal2 at next PitOutTime / out_lap_flag
  ## WORKS FOR FRENCH AND DUTCH GPs
  ## Used for Monaco as well
  
  session_ending_rf <- tibble("season" = double(),
                              "raceName" = character(),
                              "Driver" = character(),
                              "LapNumber" = double(),
                              "session_ending_flag" = double()) %>%
    add_row("season" = 2021,
            "raceName" = "French Grand Prix",
            "Driver" = "MSC",
            "LapNumber" = 7,
            "session_ending_flag" = 1) %>%
    add_row("season" = 2021,
            "raceName" = "Dutch Grand Prix",
            "Driver" = "LAT",
            "LapNumber" = 16,
            "session_ending_flag" = 1) %>%
    add_row("season" = 2021,
            "raceName" = "Monaco Grand Prix",
            "Driver" = "VET",
            "LapNumber" = 20,
            "session_ending_flag" = 1) %>%
    add_row("season" = 2021,
            "raceName" = "Azerbaijan Grand Prix",
            "Driver" = "VET",
            "LapNumber" = 11,
            "session_ending_flag" = 1) %>%
    add_row("season" = 2021,
            "raceName" = "Azerbaijan Grand Prix",
            "Driver" = "RIC",
            "LapNumber" = 14,
            "session_ending_flag" = 1)
  
  # load data
  
  # circuit <- "imola"
  
  quali_reference_data <- tbl %>%
    # filter(!(raceName %in% c("Dutch Grand Prix", "zandvoort") & Driver == "LAT" & LapNumber == 15)) %>% # problematic lap, getting towed to pits i think
    # filter(!(raceName == "French Grand Prix" & Driver == "MSC" & LapNumber == 7)) %>% 
    mutate(Sector1Time_outlap = ifelse(!is.na(PitOutTime), (Sector2SessionTime-PitOutTime-Sector2Time), NA),
           # LapStartTime alone should not be used for this logic
           # use PitOutTime as LapStartTime for outlaps, LapStartTime for non-outlaps
           coal_LapStartTime = coalesce(PitOutTime, LapStartTime)) %>%
    arrange(coal_LapStartTime) %>% # this is important
    # create rolling "scores" for track status? 
    mutate(track_status_1 = dplyr::if_else(TrackStatus == "1", 1, 0),
           track_status_n1 = dplyr::if_else(TrackStatus != "1", 1, 0),
           lag_track_status_1_score_r = zoo::rollsum(lag(track_status_1), k = 4, align = "right", fill = NA),
           lag_track_status_n1_score_r = zoo::rollsum(lag(track_status_n1), k = 4, align = "right", fill = NA)
           ) %>%
    mutate(last_coal_LapStartTime = lag(coal_LapStartTime),
           last_coal_LapStartTime_delta = (coal_LapStartTime - last_coal_LapStartTime),
           last_TrackStatus = lag(TrackStatus),
           session_break_flag_coal_t = ifelse((last_coal_LapStartTime_delta >= break_seconds & !(str_detect(last_TrackStatus, "5") | lag_track_status_n1_score_r > 2)), 1, 0)
           ) %>%
    fill(session_break_flag_coal_t, .direction = "up") %>% # keep
    mutate(session_number_coal_t = as.factor(as.character((cumsum(session_break_flag_coal_t) + 1))) # keep
           ) %>%
    # dont think the below LapStartTime session breaks will be needed
    arrange(LapStartTime) %>% # this is important
    mutate(last_LapStartTime = lag(LapStartTime),
           last_LapStartTime_delta = (LapStartTime - last_LapStartTime)) %>%
    # look to moving session end logic here
    # session ending red flag logic (test case: France, MSC, LapNumber 7)
    left_join(session_ending_rf, by = c("season" = "season",
                                        "raceName" = "raceName",
                                        "Driver" = "Driver",
                                        "LapNumber" = "LapNumber")) %>%
    mutate(session_ending_flag = replace_na(session_ending_flag, 0)) %>%
    arrange(coal_LapStartTime)
  
  # 
    
  session_ending_coal_LapStartTime2 <- quali_reference_data %>%
    group_by(season, raceName, session_ending_flag) %>%
    summarize(min_session_ending_coal_LapStartTime = min(coal_LapStartTime),
              .groups = "drop")
  
  max_session_ending_flag <- max(session_ending_coal_LapStartTime2$session_ending_flag)
  
  min_session_ending_coal_LapStartTime <- session_ending_coal_LapStartTime2 %>% 
    filter(session_ending_flag == 1) %>%
    pull(min_session_ending_coal_LapStartTime)
  
  # end: 
    
  
  quali_reference_data <- quali_reference_data %>%
  # remove debug logic here
    select(season, raceName, Driver, DriverNumber, LapNumber, lap_start_rownum, PitInTime, PitOutTime,
           LapTime5, coal_LapStartTime,
           TrackStatus, last_TrackStatus, lag_track_status_1_score_r, lag_track_status_n1_score_r,
           last_coal_LapStartTime, last_coal_LapStartTime_delta,
           track_status_1, track_status_n1,
           session_break_flag_coal_t, session_number_coal_t,
           session_ending_flag) %>%
  # remove debug logic here
    
    # session ending red flag logic (test case: France, MSC, LapNumber 7)
    ## need GAS LapNumber9 to trigger start of Q2?
    ## worst case now, could use: session_number_coal_f for qualis with session ending rfs
    ##                          : session_number_coal2 for straightforward sessions, as is
    mutate(running_session_ending_rf = cumsum(session_ending_flag)) %>%
    {if (max_session_ending_flag == 1) 
      mutate(., after_rf = ifelse( (season %in% session_ending_coal_LapStartTime2$season & 
         raceName %in% session_ending_coal_LapStartTime2$raceName & coal_LapStartTime >= min_session_ending_coal_LapStartTime), 1, 0)) else 
           mutate(., after_rf = 0)} %>%
    group_by(season, raceName, running_session_ending_rf) %>%
    arrange(coal_LapStartTime) %>%
    mutate(rownum_PitOut_session_ending_rf = row_number(PitOutTime)) %>%
    # group_by(season, raceName, running_session_ending_rf, after_rf, rownum_PitOut_session_ending_rf) %>%
    mutate(rownum_PitOut_session_ending_rf2 = rownum_PitOut_session_ending_rf) %>%
    # ungroup() %>%
    fill(rownum_PitOut_session_ending_rf2, .direction = "up") %>%
    mutate(rownum_PitOut_session_ending_rf3 = replace_na(rownum_PitOut_session_ending_rf2,0),
           session_break_flag_coal_t2 = ifelse((after_rf == 1 & rownum_PitOut_session_ending_rf == 1 & rownum_PitOut_session_ending_rf2 == 1), 1, session_break_flag_coal_t)) %>%
    ungroup() %>%
    mutate(session_break_flag_coal_t3 = session_break_flag_coal_t2) %>%
    fill(session_break_flag_coal_t3, .direction = "down")  %>%
    mutate(session_break_flag_coal_f = ifelse(after_rf == 1, session_break_flag_coal_t3, session_break_flag_coal_t2),
           session_number_coal_f = as.factor(as.character((cumsum(session_break_flag_coal_f) + 1))),
           # Monza is a special case of over 6.5 minutes of not a single lap in Q2...
           session_number_coal_f = case_when(season == 2021 & raceName == "Italian Grand Prix" & session_number_coal_f == "3" ~ "2",
                                             season == 2021 & raceName == "Italian Grand Prix" & session_number_coal_f == "4" ~ "3",
                                             TRUE ~ as.character(session_number_coal_f)))
    # should be in a better spot, need to finish logic for detecting the end of the session
    ## for laps after the MSC: LapNumber7 and the next laps where PitOutTime !is.na()

  
  quali_reference_agg_coal <- quali_reference_data %>%
    group_by(session_number_coal_f) %>%
    summarize(dis_Drivers = n_distinct(Driver),
              min_coal_LapStartTime = min(coal_LapStartTime),
              max_coal_LapStartTime = max(coal_LapStartTime),
              max_RedFlag = max(ifelse(TrackStatus == "5", 1, 0))) %>%
    ungroup()
  
  # remove the below once all GPs verified
  
  # quali_reference_data %>% 
  #   filter(session_number_coal_f == 3) %>%
  #   count(Driver)
  
  return(quali_reference_agg_coal)
  
}


hclust_exclude <- function(tbl, exclude = c("InLap_flag", "OutLap_flag")) {
  
  # need a function that passes conditions to pass prior to training hclust model
  
  # test variables
  # exclude = c("InLap_flag", "OutLap_flag")
  # tbl <- rec_df
  
  # tbl <- lap_data_raw
  
  exclude_list <- do.call(paste0, list(exclude))
  
  assertthat::assert_that(max(names(tbl) %in% exclude_list) == 1,
                          msg = paste0(paste(exclude_list, collapse = ' and '), " does not exist in tbl."))
  
  # create filtered data
  
  tbl_clust <- tbl %>%
    filter(if_all(all_of(exclude_list), ~ . == "0")) %>%
    # working with this for now
    ## the final logic should be if any sector is abnormal, then the lap is excluded from hclust() 
    filter(scale_LapTime5_filtered <= 3) %>% # any laps > 3 std. devs from the subsetted mean are excluded from clustering
    select(Driver, LapNumber, LapTime5)
    
  # create hclust on filtered data
  
  tbl_clust$hclust <- tbl_clust %>%
    select(LapTime5) %>%
    dist() %>%
    hclust(method = "single") %>%
    cutree(2) %>%
    factor()
  
  # join filtered data onto raw data
  
  tbl <- tbl %>%
    left_join(select(tbl_clust, -LapTime5), by = c("Driver", "LapNumber"))
  
  # debug, TSU NA fast laps
  ## laps are fine here
  
  # tbl <- tbl %>%
  #   filter(Driver == "VER") %>%
  #   dplyr::select(Driver, LapNumber, PitInTime, PitOutTime, LapTime5, hclust)
  
  
  
  # final cleaning logic for aborted laps
  
  # get scaled Sector3Time for hclust: 1 only
  ## why is HAM lap 23 showing here?
  
  tbl_hclust1 <- tbl %>%
    # debug, remove
    # dplyr::select(Driver, LapNumber, session_number_coal_f, PitInTime, PitOutTime, Sector3Time, scale_Sector3Time, LapTime5, hclust) %>%
    # filter(Driver == "VER") %>% # VER, LapNumber 18 should not be NA.. actually, yes it should.. aborted lap at end
    # debug, remove
    filter(hclust == 1) %>%
    select(season, raceName, Driver, DriverNumber, LapNumber, session_number_coal_f, lap_start_rownum, Compound, hclust, LapTime5, Sector3Time) %>%
    mutate(scaled_Sector3Time = scale(Sector3Time)) %>%
    # cant do aborted lap logic until here, after filtering to only fast laps
    # aborted lap logic
    group_by(season, raceName, Driver, Compound) %>%
    arrange(season, raceName, Driver, Compound, lap_start_rownum) %>%
    mutate(last_driver_compound_LapTime5 = lag(LapTime5),
           last_driver_compound_delta_sec = (LapTime5 - last_driver_compound_LapTime5),
           last_driver_compound_delta_pct = ((LapTime5 - last_driver_compound_LapTime5) / last_driver_compound_LapTime5)) %>%
    ungroup() %>%
    arrange(DriverNumber, Compound, lap_start_rownum) %>%
    # have to explicitly keep NAs here
    # remove any lap that is > 1% increase from previous lap on same compound (assuming outliers, not assoc. w/ track evo)
    # could also flag and then compare with and without.. 
    filter(is.na(last_driver_compound_delta_pct) | last_driver_compound_delta_pct <= .01) %>%
    filter(is.na(scaled_Sector3Time) | scaled_Sector3Time < 3) %>%
    ungroup() %>%
    mutate(hclust1_final = hclust) %>% # think i can remove this
    select(Driver, LapNumber, hclust1_final)
  
  # joining hclust1 edit table back onto main tbl
  ## then converting any false fast laps back to NA, from hclust: 1
  
  tbl <- tbl %>%
    left_join(tbl_hclust1, by = c("Driver", "LapNumber")) %>%
    mutate(hclust = ifelse(hclust == 1 & is.na(hclust1_final), NA, hclust),
           hclust = as.factor(as.character(hclust)))
  
  
  return(tbl)
  
}


# function that accepts a list of circuitids to iterate through and load

compile_driver_data <- function(season='2021',
                                circuit, 
                                session = 'Q',
                                driver = 'ALL',
                                data_type = 'laps',
                                cached_flag) {
  
  # season <- '2021'
  # circuit <- 'Styrian Grand Prix'
  # circuit <- 'Abu Dhabi Grand Prix'
  # session <- 'Q'
  # driver <- 'ALL'
  # data_type <- 'laps'
  
  if (toupper(session) == "Q") {
    
    # load quali reference table
    
    # season <- '2021'
    # circuit <- 'interlagos'
    # session <- 'SQ'
    # driver <- 'ALL'
    # data_type <- 'laps'
    
    # quali_ref_data <- get_quali_reference(season,
    #                                       circuit)
    
    # load and clean qualifyinh lap data
    ## joining above quali reference table
    
    lap_data_raw <- get_driver_data(season,
                                   circuit,
                                   session,
                                   driver,
                                   data_type,
                                   cached_flag) %>%
      clean_lap_data()
    
    
    lap_data_quali_ref <- lap_data_raw %>%
      get_quali_reference_tbl()
    
    
    lap_data_raw <- lap_data_raw %>%
      # will need to add argument in join for circuit / gp
      ## looks like map_df compiles this one race at a time, so i can get away with this as is
      fuzzyjoin::fuzzy_join(lap_data_quali_ref,
                        by = c("coal_LapStartTime" = "min_coal_LapStartTime",
                               "coal_LapStartTime" = "max_coal_LapStartTime"),
                        match_fun = list(`>=`, `<=`)) %>%
      hclust_exclude(exclude = c("InLap_flag", "OutLap_flag"))
    
  } else {
    
    stop("Only supporting qualifying sessions for now.")
    
  }
  
  return(lap_data_raw)
  
}


```

<br/>

The important function below is *compile_driver_data* that is being called within *map_df*. Within *compile_driver_data* are a series of created functions that serve to clean and cluster the data, which was seen earlier in this analysis. This is just an extra tool to apply that code, plus some additional code to deal with the intricacies that come from other qualifying sessions (mainly red flags that cause one or more prolonged stoppages), to an entire season of qualifying sessions.

As seen in the code below, we are also removing three qualifying sessions that featured wet conditions. Since the goal of the analysis is to measure the decrease in laptimes while holding as many variables as possible constant, wet track conditions are problematic in that they can do anything from wiping out all rubber/grip that had been built up on the track to that point in a race weekend to conditions varying from the start of a session to the end. This was seen in Turkey this past season, where the start of the session saw a wet track conditions that improved to dry over the course of qualifying. When this happens, the track evolution seen is surely due to improving conditions which isn't what the point of this analysis is. Though, it would be interesting to do a separate analysis on lap times against weather conditions. 
  
  
```{r, message=FALSE, warning=FALSE}

# need to exclude / replace sprint qualifyings with traditional qualifying? 

wet_qualis_2021 <- c("Belgian Grand Prix",
                     "Russian Grand Prix",
                     "Turkish Grand Prix")

circuits_2021 <- get_weekend_gp(season = '2021') %>%
  dplyr::filter(!(raceName %in% wet_qualis_2021)) %>%
  select(raceName, round, season)

ad_compile_test_mult <- circuits_2021$raceName %>%
  map_df(~ compile_driver_data(season = '2021',
                               circuit = .x,
                               # session = NULL,
                               driver = 'ALL',
                               data_type = 'laps',
                               cached_flag = 'True'))

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# override of monaco and portugal hclust
## not putting in hclust_exclude(), can if needed.. 

ad_compile_test_mult <- ad_compile_test_mult %>%
  mutate(hclust = case_when((raceName == "Monaco Grand Prix" & hclust == 1 & LapTime5 > 74) | 
                              (raceName == "Portuguese Grand Prix" & hclust == 1 & LapTime5 > 85.5) |
                              (raceName ==  "Saudi Arabian Grand Prix" & hclust == 1 & LapTime5 > 93) ~ "2",
                            (raceName == "Saudi Arabian Grand Prix" & hclust == 2 & LapTime <= 93) ~ "1",
                            # (raceName == "Saudi Arabian Grand Prix" & hclust == 1 & LapTime > 93) ~ "2",
                            TRUE ~ as.character(hclust))
         )

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# use Abu Dhabi as control for testing

# need to include filtering of only q3 drivers by raceName

ad_compile_q3_drivers <- ad_compile_test_mult %>%
  # filter(raceName == "Abu Dhabi Grand Prix") %>%
  # select(raceName, Driver, session_number_coal2) %>%
  select(raceName, Driver, session_number_coal_f) %>%
  group_by(raceName, Driver) %>%
  # summarize(max_session = max(as.numeric(as.character(session_number_coal2))),
  #           .groups = "drop") %>%
  summarize(max_session = max(as.numeric(as.character(session_number_coal_f))),
            .groups = "drop") %>%
  filter(max_session == 3)

# include only fast laps from drivers that made it to Q3 per GP

ad_quali_2021_l_fast_compile <- ad_compile_test_mult %>%
  inner_join(ad_compile_q3_drivers, by = c("Driver" = "Driver",
                                           "raceName" = "raceName")) %>%
  filter(hclust == 1)
  
  ##########

  # this logic below is now being replicated in hclust_exclude()
  ## most likely remove once the entire function looks feasible across all races
  
  
# function of gam model
## need to add condition to remove Compound for when no drivers use mediums in quali
## this is going to happen for every dry qualifying for sprint qualifying weekends

gam_quali_model <- function(df, compound_len, ...) {
  
  # compound_len == 2
  
  # df <- ad_quali_2021_l_fast_compile
  # df <- ad_quali_2021_l_fast_compile %>%
  #   filter(raceName == "Hungarian Grand Prix")
  
  if (compound_len > 1) {
    
    ad_q3_driver_gam_compile <- mgcv::gam(LapTime5 ~ s(lap_start_rownum, by = Compound, ...) + Compound + Team,
                                  data = df, method = "REML")
    
  } else if (compound_len == 1) {
    
    ad_q3_driver_gam_compile <- mgcv::gam(LapTime5 ~ s(lap_start_rownum, ...) + Team,
                                  data = df, method = "REML")
    
  } else {
    
    stop("No Compound levels for model fitting!")
    
  }
  
  return(ad_q3_driver_gam_compile)
  
}

# fit models and flag problematic GPss for parameter verride

to_set_clustering <- c("Monaco Grand Prix",
                       "Portuguese Grand Prix",
                       "Saudi Arabian Grand Prix")

quali_gam_df <- ad_quali_2021_l_fast_compile %>%
  group_by(season, raceName) %>%
  # if manually setting smoothing params, needs to be added here and in gam_quali_model()
  # mgcv::gam sp arg defaults to NULL, so any race I am not manually overriding can have sp = NULL
  mutate(len_Compound = length(unique(Compound[!is.na(Compound)])),
         gam_lambda = case_when(raceName == "Bahrain Grand Prix" ~ 4,
                                raceName == "Hungarian Grand Prix" ~ 4,
                                raceName == "Monaco Grand Prix" ~ 4)) %>%
  group_by(season, raceName, len_Compound, gam_lambda) %>%
  nest() %>%
  # filter(!(raceName %in% to_set_clustering)) %>%
  # filter(!(raceName %in% c("French Grand Prix", "Mexico City Grand Prix"))) %>%  # need to fix these two
  mutate(gam_model = data %>% map(~gam_quali_model(., compound_len = len_Compound, sp = switch(is.na(gam_lambda) + 1, gam_lambda, NULL)))) %>%
  # mutate(gam_model2 = map2(gam_quali_model, data, ))
  ungroup()


# generalize this for all qualifyings

f_fit_predict_compile <- function(df) {
  
  # df <- quali_gam_df
  
  quali_gam_df_grp <- df %>%
    unnest(data) %>%
    select(season, raceName, Team, lap_start_rownum) %>%
    group_by(season, raceName, Team) %>%
    summarize(min_lap_start_rownum = min(lap_start_rownum),
              start_session = 1, # dont think i need this
              max_lap_start_rownum = max(lap_start_rownum)) %>%
    ungroup() 

  
  fit_predict_compile <- quali_gam_df_grp %>%
    group_by(season, raceName) %>%
    expand(Team,
           lap_start_rownum = 1:max(max_lap_start_rownum),
           Compound = "SOFT") %>%
    nest() %>%
    rename("pred_data" = data) %>%
    ungroup()
  
  # fit_predict_compile <- expand.grid(season = unique(quali_gam_df_grp$season),
  #                                    raceName = unique(quali_gam_df_grp$raceName),
  #                                    ) %>%
  #   # group_by(season, raceName) %>%
  #   expand.grid(#season = unique(quali_gam_df_grp$season),
  #             #raceName = unique(quali_gam_df_grp$raceName),
  #              lap_start_rownum = 1:max(quali_gam_df_grp$max_lap_start_rownum[quali_gam_df_grp$season == season & quali_gam_df_grp$raceName == raceName])) # only going up until the amount of laps we have recorded in training
  #              Team = unique(quali_gam_df_grp$Team),
  #              Compound = "SOFT") %>%
  #   group_by(season, raceName) %>%
  #   nest() %>%
  #   rename("pred_data" = data) %>%
  #   ungroup()
  
  return(fit_predict_compile)
  
}

# simple function to remove .rownames columns when they exist

remove_rownames <- function(df) {
  
  df <- df %>%
    select_if(!(names(.) %in% c(".rownames")))
  
  return(df)
  
}


# join nested, prediction dataset onto quali_gam_df

quali_gam_df <- quali_gam_df %>%
  group_by(season, raceName) %>%
  mutate(#tidy = map(gam_model, broom::tidy),
         #glance = map(gam_model, broom::glance),
         preds_obs = map(gam_model, broom::augment),
         preds_obs = map(preds_obs, remove_rownames)
         ) %>%
  # left_join(fit_predict_compile, by = c("season", "raceName")) %>%
  left_join(f_fit_predict_compile(.), by = c("season" = "season",
                                             "raceName" = "raceName")) %>%
  # group_by(season, raceName) %>%
  mutate(preds_new = map2(gam_model, pred_data, ~broom::augment(.x, newdata = .y))) %>%
  ungroup()


# create function to safely unnest and deselect nested / list columns
## also added argument to allow for creation of confidence intervals
### when needed columns exist, passing if not

unpack_safely <- function(tbl, col, data_to_keep=NULL, add_conf = FALSE) {
  
  # tbl <- quali_gam_df
  # col <- "preds_obs"
  # data_to_keep <- c("Driver", "TrackStatus")
  # data_to_keep <- NULL
  
  # detect nested columns in tbl
  
  nested_columns_df <- sapply(tbl, class) %>%
    as.data.frame() %>%
    rename("var_type" = ".")
  
  nested_columns_df$var_names <- rownames(nested_columns_df)
  rownames(nested_columns_df) <- 1:nrow(nested_columns_df)
  
  # convert to list of names for nested column names
  
  nested_columns_list <- nested_columns_df %>%
    filter(var_type == "list") %>%
    pull(var_names)
  
  # select identifiers + specified columns to keep from training data
  
  if (!is.null(data_to_keep)) {
    
     data_keep_df <- tbl %>%
       unnest(data) %>%
       # select only identifiers + list of columns to keep
       select(season, raceName, lap_start_rownum, all_of(data_to_keep))
    
  } else {
    
      data_keep_df <- tbl %>%
        unnest(data) %>%
        # select only identifiers
        select(season, raceName, lap_start_rownum)
    
  }
  
  # unnest specified column and drop all remaining nested columns
  
  tbl <- tbl %>%
    unnest(cols = col) %>%
    select_if(!(names(.) %in% nested_columns_list)) %>%
    left_join(data_keep_df, by = c("season" = "season",
                                   "raceName" = "raceName",
                                   "lap_start_rownum" = "lap_start_rownum"))
  
  # add confidence interval for fitted values
  
  if (add_conf) {
    
    # detect if .fitted and .se.fit exist and if so, calc conf ints
    
    if (max(str_detect(names(tbl), ".fitted")) == 1 &
        max(str_detect(names(tbl), ".se.fit")) == 1) {
      
      tbl <- tbl %>%
        mutate(lower = .fitted - 1.96 * .se.fit,
               upper = .fitted + 1.96 * .se.fit)
      
    } else {
      
      message("No fitted values found, passing.")
      invisible()
      
    }
    
  }
  
  return(tbl)
  
}

# create a reference table to translate lap_start_rownum and running time
# could also look at lap_start_rownum as a percentage of session progress

# options(scipen = 99999)
quali_gam_pred_agg <- quali_gam_df %>%
  # unnest(cols = preds_new) %>% View()
  unpack_safely(col = "preds_new",
                add_conf = TRUE,
                data_to_keep = c("Driver", "TrackStatus")) %>% 
  group_by(raceName, lap_start_rownum) %>%
  summarize(raceName_mean_fitted = mean(.fitted)) %>%
  group_by(raceName) %>%
  mutate(raceName_first_fitted = first(raceName_mean_fitted),
         raceName_last_fitted = last(raceName_mean_fitted),
         mean_pct_decrease_evo = ((raceName_first_fitted - raceName_mean_fitted) / raceName_first_fitted),
         raceName_last_laps_start_rownum = last(lap_start_rownum),
         pct_raceName_laps = (lap_start_rownum / raceName_last_laps_start_rownum)) %>%
  ungroup()

```

The bread and butter of this portion of the analysis comes from a concept used in R called nesting. Nesting lets us essentially iterate whatever it is that we want to do by specific groups. In this case - we've got a lap for every qualifying session, but what is needed is an effective separation of the things that we do to be between qualifying sessions in 2021 rather than, say, entire seasons. 

Below is a nested dataframe. Instead of having a row for every lap, we have a row for every qualifying session in 2021. Within these rows are objects built within the datafame, which is where the term nesting comes from. 
  

```{r}

quali_gam_df

```

The objects that are created for each qualifying session are:

  - *len_Compound*
    - This is just a plain, old integer representing the maximum number of tires used in a qualifying session for any team. In most qualifying sessions throughout the season, the top teams would elect to at least attempt a stint in Q2 on the medium compound. This integer is used as a condition for determining which of the following models to use, per qualifying. If there were more than compound of tires used in a qualifying session - then add compound as a variable in the model, if not - leave compound out of the model. Once again, leaving compound in the model was mostly to satisfy my curiosity, rather than having any serious reason due to the very low sample of laps that used medium compound tires in comparison to the softs. 
    
```{r, eval=FALSE, message=FALSE, warning=FALSE}

gam_quali_model <- function(df, compound_len, ...) {
  
  # compound_len == 2
  
  # df <- ad_quali_2021_l_fast_compile
  # df <- ad_quali_2021_l_fast_compile %>%
  #   filter(raceName == "Hungarian Grand Prix")
  
  if (compound_len > 1) {
    
    ad_q3_driver_gam_compile <- mgcv::gam(LapTime5 ~ s(lap_start_rownum, by = Compound, ...) + Compound + Team,
                                  data = df, method = "REML")
    
  } else if (compound_len == 1) {
    
    ad_q3_driver_gam_compile <- mgcv::gam(LapTime5 ~ s(lap_start_rownum, ...) + Team,
                                  data = df, method = "REML")
    
  } else {
    
    stop("No Compound levels for model fitting!")
    
  }
  
  return(ad_q3_driver_gam_compile)
  
}

```
    
    
  - *gam_lambda*
    - This is another integer, referred to as *lambda* ( $\lambda$ ), which is used as a penalty parameter. When the models are created, we want to capture non-linear trends without our fitted model being a straight line or too "wiggly". The $\lambda$ value allows us to adjust the "wigglyness" of each model. For the majority of the 19 qualifying sessions that we built GAM models for, we let the model default to its own $\lambda$ value. However, for Bahrain, Hungary, and Monaco our models were not generalizing to the data well (known as over-fitting) and needed this parameter set manually. In each case, setting $\lambda = 4$ allowed us to remove excessive wigglyness. 
  
  - *data*
    - The "original" dataframe featuring the fast laps for all drivers per qualifying session.
    
  - *gam_model*
    - A GAM object that is created using the *data* dataframe.
    
  - *preds_obs*
    - Seen in the beginning of the **Analysis** section, a dataframe containing each lap observed from *data*, but with GAM model outputs ("predictions", confidence intervals, .etc) built from *gam_model*.
  
  - *pred_data*
    - The dataframe created that contains one lap, per team, per qualifying session, all on soft compound tires. This is the dataframe that allows us to analyze the many GAM models on data that may have not been seen in the actual qualifying sessions.
    
```{r}

quali_gam_df %>%
  dplyr::filter(raceName == "Bahrain Grand Prix") %>%
  unpack_safely(col = "pred_data",
                add_conf = TRUE) %>%
  head() %>%
  kbl() %>%
  kable_styling(position = "center")

```
    
  - *preds_new*
    - A dataframe that contains *pred_data* and additional columns for GAM model outputs that result from applying the *gam_model* to *pred_data*. 

```{r}

quali_gam_df %>%
  dplyr::filter(raceName == "Bahrain Grand Prix") %>%
  unpack_safely(col = "preds_new",
                add_conf = TRUE) %>%
  head() %>%
  kbl() %>%
  kable_styling(position = "center")

```


```{r, eval=FALSE, echo=FALSE, warning=FALSE, message=FALSE}

gp_select <- "Portuguese Grand Prix"
# gp_select <- "Mexico City Grand Prix"
# gp_select <- "Abu Dhabi Grand Prix"
# gp_select <- "Saudi Arabian Grand Prix"

# smoothed line over actual lap times
  
quali_gam_df %>%
  unpack_safely(col = "preds_obs",
                add_conf = TRUE) %>% 
  filter(raceName == gp_select) %>%
  ggplot(aes(x = lap_start_rownum, y = LapTime5, color = Compound)) +
  geom_point() +
  # geom_smooth(method = "gam") +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
  geom_line(aes(x = lap_start_rownum, y = .fitted, group = Compound), color = "purple") +
  labs(title = "Lap Time Predictions per Session Progress, Team, Tire Compound",
       subtitle = paste0(gp_select, " ", "Qualifying, Drivers who made Q3 only"), 
       x = "Laps Started",
       y = "Lap Time") +
  sec_lab_convert(axis = "y",
                  start_sec = 60,
                  end_sec = 180,
                  int_sec = 0.5) +
  facet_wrap(~fct_reorder(Team, -LapTime5),
             nrow = 1) +
  scale_color_manual(values = c("SOFT" = "RED",
                                "MEDIUM" = "#e3a600")) +
  theme_main() +
  theme_main_add()

```

<br/>

## Conclusion

After pulling, cleaning, and building models for each qualifying session in the 2021 season, we can compare which circuits had the largest average decreases in lap times. Many sessions have different trends that occur as qualifying progressed, some are pretty linear and others - like Saudi Arabia - can take on more-complex shapes, a good indicator of track evolution having different behaviors at different circuits throughout the season. 

As an example, Mexico City saw a steep decrease in lap times from the start of qualifying and saw the biggest percent change. On the contrary, Portugal saw the least. There are pretty good reasons for each of these, as mentioned on the broadcast for Mexico City's qualifying - it is a circuit that hardly gets used outside of the F1 race weekend. Combine the lack of usage with the dusty nature of Mexico City's air, and the circuit is constantly evolving and improving as cars are able to get laps in, which cleans the track surface and lays rubber down in the process. Portugal, on the other hand, is a very smooth track surface with very little grip. The racing there is challenging for drivers as they struggle to manage the many elevation changes in combination with the track surface being one of the slickest that F1 has raced on in recent years. 


```{r, fig.align='center', fig.height=7.5, fig.width=14, warning=FALSE, message=FALSE}

# final step: attempt to scale laps_start_rownum on a scale of 0-1 by raceName
## note that this is for viz purposes only, and obviously wont be able to project that in realtime

# scale laps to % session progress

quali_gam_pred_agg %>%
  ggplot(aes(x = pct_raceName_laps, y = mean_pct_decrease_evo,
             color = raceName, group = raceName)) +
  geom_line(show.legend = FALSE) +
  geom_label_repel(aes(label = raceName, x = 1.025),
                   data = quali_gam_pred_agg %>% 
                            filter(pct_raceName_laps == 1) %>%
                            select(raceName, mean_pct_decrease_evo, pct_raceName_laps),
                   alpha = 0.8,
                   size = 2,
                   # nudge_x = 1.7,
                   xlim = c(1,1.6),
                   show.legend = FALSE) +
  # geom_point() +
  labs(title = "Average Decrease in Lap Times per Qualifying Session",
       subtitle = "Portugal saw the least relative improvements in overall lap times, while Mexico City, Italy, and Monaco saw the most",
         x = "Qualifying Progress",
       y = "Average Decrease in Lap Times",
       color = "Race") +
  coord_cartesian(xlim = c(0,1.15)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1),
                     breaks = seq(0,1,0.25)) +
  scale_y_reverse(labels = scales::percent_format(accuracy = 0.01)) +
  theme_main() + 
  theme_main_add()


```







